/* 
 * Gitea API
 *
 * This documentation describes the Gitea API.
 *
 * OpenAPI spec version: 1.21.11
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

/// NotificationThread : NotificationThread expose Notification on API

#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct NotificationThread {
  #[serde(rename = "id")]
  id: Option<i64>,
  #[serde(rename = "pinned")]
  pinned: Option<bool>,
  #[serde(rename = "repository")]
  repository: Option<::models::Repository>,
  #[serde(rename = "subject")]
  subject: Option<::models::NotificationSubject>,
  #[serde(rename = "unread")]
  unread: Option<bool>,
  #[serde(rename = "updated_at")]
  updated_at: Option<String>,
  #[serde(rename = "url")]
  url: Option<String>
}

impl NotificationThread {
  /// NotificationThread expose Notification on API
  pub fn new() -> NotificationThread {
    NotificationThread {
      id: None,
      pinned: None,
      repository: None,
      subject: None,
      unread: None,
      updated_at: None,
      url: None
    }
  }

  pub fn set_id(&mut self, id: i64) {
    self.id = Some(id);
  }

  pub fn with_id(mut self, id: i64) -> NotificationThread {
    self.id = Some(id);
    self
  }

  pub fn id(&self) -> Option<&i64> {
    self.id.as_ref()
  }

  pub fn reset_id(&mut self) {
    self.id = None;
  }

  pub fn set_pinned(&mut self, pinned: bool) {
    self.pinned = Some(pinned);
  }

  pub fn with_pinned(mut self, pinned: bool) -> NotificationThread {
    self.pinned = Some(pinned);
    self
  }

  pub fn pinned(&self) -> Option<&bool> {
    self.pinned.as_ref()
  }

  pub fn reset_pinned(&mut self) {
    self.pinned = None;
  }

  pub fn set_repository(&mut self, repository: ::models::Repository) {
    self.repository = Some(repository);
  }

  pub fn with_repository(mut self, repository: ::models::Repository) -> NotificationThread {
    self.repository = Some(repository);
    self
  }

  pub fn repository(&self) -> Option<&::models::Repository> {
    self.repository.as_ref()
  }

  pub fn reset_repository(&mut self) {
    self.repository = None;
  }

  pub fn set_subject(&mut self, subject: ::models::NotificationSubject) {
    self.subject = Some(subject);
  }

  pub fn with_subject(mut self, subject: ::models::NotificationSubject) -> NotificationThread {
    self.subject = Some(subject);
    self
  }

  pub fn subject(&self) -> Option<&::models::NotificationSubject> {
    self.subject.as_ref()
  }

  pub fn reset_subject(&mut self) {
    self.subject = None;
  }

  pub fn set_unread(&mut self, unread: bool) {
    self.unread = Some(unread);
  }

  pub fn with_unread(mut self, unread: bool) -> NotificationThread {
    self.unread = Some(unread);
    self
  }

  pub fn unread(&self) -> Option<&bool> {
    self.unread.as_ref()
  }

  pub fn reset_unread(&mut self) {
    self.unread = None;
  }

  pub fn set_updated_at(&mut self, updated_at: String) {
    self.updated_at = Some(updated_at);
  }

  pub fn with_updated_at(mut self, updated_at: String) -> NotificationThread {
    self.updated_at = Some(updated_at);
    self
  }

  pub fn updated_at(&self) -> Option<&String> {
    self.updated_at.as_ref()
  }

  pub fn reset_updated_at(&mut self) {
    self.updated_at = None;
  }

  pub fn set_url(&mut self, url: String) {
    self.url = Some(url);
  }

  pub fn with_url(mut self, url: String) -> NotificationThread {
    self.url = Some(url);
    self
  }

  pub fn url(&self) -> Option<&String> {
    self.url.as_ref()
  }

  pub fn reset_url(&mut self) {
    self.url = None;
  }

}



